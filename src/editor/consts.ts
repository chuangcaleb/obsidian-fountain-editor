export const TOKEN_NAMES = {
	sceneHeading: "scene-heading",
	formattingSceneHeading: "formatting-scene-heading",
	action: "action",
	character: "character",
	dialogue: "dialogue",
	parenthetical: "parenthetical",
	lyrics: "lyrics",
	centered: "centered",
	transition: "transition",
	section: "section",
	synopsis: "synopsis",
	boneyard: "boneyard",
	fBoneyardStart: "formatting-boneyard-start",
	fBoneyardEnd: "formatting-boneyard-end",
	pageBreak: "page-break",
} as const;

const n = TOKEN_NAMES;

// transparency: this list is enhanced and generated by ChatGPT
const sceneHeadingPrefixesMap = {
	// - Latin: INT, EXT, EST, I/E, INT/EXT
	latin: ["int", "ext", "est", "i/e", "int/ext"],

	// - Russian: ИНТ, НАТ, ЭСТ, И/Н, ИНТ/НАТ
	russian: ["инт", "нат", "эст", "и/н", "инт/нат"],

	// - Ukrainian: ІНТ, НАТ, ЕСТ, І/Н, ІНТ/НАТ
	ukrainian: ["інт", "нат", "ест", "і/н", "інт/нат"],

	// - Bulgarian: ВН, ИЗН, ВН/ИЗН
	bulgarian: ["вн", "изн", "вн/изн"],

	// - Serbian/Macedonian: ВН, НАДВ, ВН/НАДВ
	serbianMacedonian: ["вн", "надв", "вн/надв"],

	// - Greek: ΕΣΩ. (INT), ΕΞΩ. (EXT), ΕΣΩ/ΕΞΩ. (INT/EXT)
	//   Sometimes ΕΣΤ. for "establishing"
	greek: ["εσω", "εξω", "εσω/εξω", "εστ"],

	// - Hebrew: פנ. (INT = פנימי), חוץ. (EXT), פנ/חוץ. (INT/EXT)
	//   NB: Hebrew is RTL but regex still matches left-to-right in source
	hebrew: ["פנ", "חוץ", "פנ/חוץ"],

	// - Arabic: د. (داخل = INT), خ. (خارج = EXT), د/خ. (INT/EXT)
	//   Sometimes spelled in full: داخل, خارج
	arabic: ["د", "خ", "د/خ", "داخل", "خارج", "داخل/خارج"],

	// - Turkish: İÇ (INT), DIŞ (EXT), İÇ/DIŞ
	turkish: ["iç", "dış", "iç/dış"],

	// - French/Spanish/Italian (they often keep English, but some use native)
	//   French: INTÉR. / EXT. ; Spanish: INT. / EXT. ; Italian: INT. / EST.
	//   Adding common alternatives
	romance: ["intér", "inter", "est", "ext"],
};

const dedupedSceneHeadingPrefixes = [
	...new Set(Object.values(sceneHeadingPrefixesMap).flat()),
];

export const LINE_TOKENS = [
	{
		id: n.sceneHeading,
		// - Scene heading int/ext
		// - Fountain Power User: dot prefix e.g. `.MONTAGE`
		regex: new RegExp(
			`^((?:\\*{0,3}_?)?(?:${dedupedSceneHeadingPrefixes.join("|")})[. ].+)|^\\.(?!\\.+)(.+)`,
			"iu",
		),
	},
	{
		id: n.action,
		// Fountain Power User: lines starting with `!`
		regex: /^!.*$/u,
	},
	{
		id: n.character,
		// - Latin uppercase
		// - Extended Latin (À-ß, etc.)
		// - Cyrillic uppercase (0400–052F)
		// Fountain Power User: `@`-prefix, e.g. `@O'McDONALD`
		regex:
			/^[^\S\r\n]*(?=.*[\p{Lu}\u0400-\u04FF\u0500-\u052F])[A-Z\d\u00C0-\u00DEF\u0400-\u04FF\u0500-\u052F \t'.-]+\s?(\(.*\))?$|@.*$/u,
	},
	{
		id: n.dialogue,
		// Dialogue must follow a character line
		regex: /^[^\S\r\n]*(\^?)?\n(?!\n+)([\s\S]+)/u,
	},
	{
		id: n.parenthetical,
		// e.g. `(whispering)`
		regex: /^[^\S\r\n]*(\(.+\))$/u,
	},
	{
		id: n.lyrics,
		// Lines starting with ~
		regex: /^~.*$/u,
	},
	{
		id: n.centered,
		// > CENTERED TEXT <
		regex: /^[^\S\r\n]*>[^<>]+<$/u,
	},
	{
		id: n.transition,
		// - Lines ending with `TO:`, e.g. `CUT TO:`
		// - Fountain Power user: `>`-prefix, e.g. `FADE TO BLACK:`
		// - Cyrillic uppercase `TO:`, e.g. `перейти к TO:`
		regex:
			/^[^\S\r\n]*(>[^<\n\r]*|[\p{Lu}\u00C0-\u024F\u0370-\u03FF\u0400-\u052F\u0590-\u05FF\u0600-\u06FF ]+ TO[:：])$/u,
	},
	{
		id: n.section,
		// e.g. `### SECTION TITLE`
		regex: /^(#+) *(.*)/u,
	},
	{
		id: n.synopsis,
		// `= Synopsis`
		regex: /^=(?!=+) *(.*)$/u,
	},
	// Note: /^(?:\[{2}(?!\[+))(.+)(?:\]{2}(?!\[+))$/,
	// note_inline: /(?:\[{2}(?!\[+))([\s\S]+?)(?:\]{2}(?!\[+))/g,
	// boneyard: /(^\/\*|^\*\/)$/g,
	{
		id: n.fBoneyardStart,
		// `/* boneyard start`
		regex: /(^\/\*$)/u,
	},
	{
		id: n.fBoneyardEnd,
		// `*/ boneyard end`
		regex: /(^\*\/$)/u,
	},
	{
		id: n.pageBreak,
		// === (3 or more)
		regex: /^={3,}$/u,
	},
] as const satisfies Array<{id: (typeof n)[keyof typeof n]; regex: RegExp}>;
